corelMatrics <- array(0, c(p, p, df))
centralMatrices[,,1] <- matrices[,,1] - Sigma
corelMatrics[,,1] <- matrices[,,1] - Sigma
pelet <- matrices[,,1]
for(i in 2:df){
centralMatrices[,,i] <- matrices[,,i] - Sigma # epsilon[i]
corelMatrics[,,i] <- centralMatrices[,,i] # X[i] = epsilon[i]
if(!is.null(AR)){
arlag <- min(maxAR, i - 1)
corelMatrics[,,i] <- corelMatrics[,,i] + summatrix(corelMatrics, (i - arlag):(i - 1), rev(AR[1:arlag]))
# X[i] = epsilon[i] + X[i-1] + ...
}
if(!is.null(MA)){
malag <- min(maxMA, i - 1)
corelMatrics[,,i] <- corelMatrics[,,i] + summatrix(centralMatrices, (i - malag):(i - 1) , rev(MA[1:malag]))
# X[i] = epsilon[i] + X[i-1] + ... + epsilon[i-1] + ...
}
pelet <- pelet + corelMatrics[,,i] + Sigma
# X[i] = epsilon[i] + X[i-1] + ... + epsilon[i-1] + ... + mu
# W = sum(X[i])
}
return(pelet)
}
if(ncores == 1) return(sapply(1:n, rawFun, simplify = "array"))
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterExport(cl, c("df", "Sigma", "AR", "MA", "maxAR", "maxMA"), envir = environment())
clusterExport(cl, "sumvector", envir = .GlobalEnv)
pelet <- parSapply(cl = cl, 1:n, rawFun, simplify = "array")
terminateCL()
return(pelet)
}
terminateCL()
rWishart_ARMA2(8, 120, diag(5), AR = 0.5, ncores = 2)
terminateCL()
summatrix
rWishart_ARMA2 <- function(n = 1, df, Sigma, AR = NULL, MA = NULL, ncores = 1){
p <- ncol(Sigma)
if(is.null(MA) & is.null(AR)) return(rWishart2(n = n, df = df, Sigma = Sigma))
if(df < p) warning("Wishart degrees of freedom lower than matrix dimension.")
maxAR <- maxMA <- NULL
if(!is.null(AR)){
if(!checkInv(AR)) stop("AR process not stationary.")
maxAR <- length(AR)
}
if(!is.null(MA)){
if(!checkInv(MA)) stop("MA process not invertable.")
maxMA <- length(MA)
}
rawFun <- function(k){
matrices <- rmvnorm(n = df, sigma = Sigma)
matrices <- sapply(1:df, function(i) matrices[i,] %*% t(matrices[i,]), simplify = "array")
centralMatrices <- array(0, c(p, p, df))
corelMatrics <- array(0, c(p, p, df))
centralMatrices[,,1] <- matrices[,,1] - Sigma
corelMatrics[,,1] <- matrices[,,1] - Sigma
pelet <- matrices[,,1]
for(i in 2:df){
centralMatrices[,,i] <- matrices[,,i] - Sigma # epsilon[i]
corelMatrics[,,i] <- centralMatrices[,,i] # X[i] = epsilon[i]
if(!is.null(AR)){
arlag <- min(maxAR, i - 1)
corelMatrics[,,i] <- corelMatrics[,,i] + summatrix(corelMatrics, (i - arlag):(i - 1), rev(AR[1:arlag]))
# X[i] = epsilon[i] + X[i-1] + ...
}
if(!is.null(MA)){
malag <- min(maxMA, i - 1)
corelMatrics[,,i] <- corelMatrics[,,i] + summatrix(centralMatrices, (i - malag):(i - 1) , rev(MA[1:malag]))
# X[i] = epsilon[i] + X[i-1] + ... + epsilon[i-1] + ...
}
pelet <- pelet + corelMatrics[,,i] + Sigma
# X[i] = epsilon[i] + X[i-1] + ... + epsilon[i-1] + ... + mu
# W = sum(X[i])
}
return(pelet)
}
if(ncores == 1) return(sapply(1:n, rawFun, simplify = "array"))
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterExport(cl, c("df", "Sigma", "AR", "MA", "maxAR", "maxMA"), envir = environment())
clusterExport(cl, "summatrix", envir = .GlobalEnv)
pelet <- parSapply(cl = cl, 1:n, rawFun, simplify = "array")
terminateCL()
return(pelet)
}
rWishart_ARMA2(8, 120, diag(5), AR = 0.5, ncores = 2)
terminateCL()
computeBmatr <- function(sickDat, CovObj, ncores = 1){
if(ncores == 1) {
Bmatr <- lapply(1:nrow(sickDat), function(j) loglikgrad_uni(sickDat[j,], CovObj))
} else {
rawFun <- function(j) loglikgrad_uni(sickDat[j,], CovObj)
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterEvalQ(cl, library(dplyr))
clusterEvalQ(cl, library(numDeriv))
clusterExport(cl, c("sickDat", "CovObj"), envir = environment())
clusterExport(cl, c("loglik_uni", "loglikgrad_uni", "vector_to_triangle","create_alpha_mat",
"vector_var_matrix_calc_COR", "triangle_to_vector"), envir = .GlobalEnv)
Bmatr <- parSapply(cl = cl, 1:nrow(sickDat), rawFun)
terminateCL()
}
#terminateCL()
Bmatr <- Bmatr %>% (function(list){
L <- length(list)
pelet <- matrix(0, nrow = nrow(list[[1]]), ncol = ncol(list[[1]]))
for(i in 1:L) pelet <- pelet + list[[i]]
pelet
})
return(Bmatr)
}
load("C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Data/Enviroments/fullRunNoARMA 2018-11-30 21-08-24.RData")
computeBmatr <- function(sickDat, CovObj, ncores = 1){
if(ncores == 1) {
Bmatr <- lapply(1:nrow(sickDat), function(j) loglikgrad_uni(sickDat[j,], CovObj))
} else {
rawFun <- function(j) loglikgrad_uni(sickDat[j,], CovObj)
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterEvalQ(cl, library(dplyr))
clusterEvalQ(cl, library(numDeriv))
clusterExport(cl, c("sickDat", "CovObj"), envir = environment())
clusterExport(cl, c("loglik_uni", "loglikgrad_uni", "vector_to_triangle","create_alpha_mat",
"vector_var_matrix_calc_COR", "triangle_to_vector"), envir = .GlobalEnv)
Bmatr <- parSapply(cl = cl, 1:nrow(sickDat), rawFun)
terminateCL()
}
#terminateCL()
Bmatr <- Bmatr %>% (function(list){
L <- length(list)
pelet <- matrix(0, nrow = nrow(list[[1]]), ncol = ncol(list[[1]]))
for(i in 1:L) pelet <- pelet + list[[i]]
pelet
})
return(Bmatr)
}
computeBmatr(cor.matrix_to_norm.matrix(sampleData$sick))
sampleData$sick
cor.matrix_to_norm.matrix(sampleData$sick)
computeBmatr(cor.matrix_to_norm.matrix(sampleData$sick), Pelet_Cov)
computeBmatr(cor.matrix_to_norm.matrix(sampleData$sick), Pelet_Cov, ncores = 3)
terminateCL()
computeBmatr <- function(sickDat, CovObj, ncores = 1){
if(ncores == 1) {
Bmatr <- lapply(1:nrow(sickDat), function(j) loglikgrad_uni(sickDat[j,], CovObj))
} else {
rawFun <- function(j) loglikgrad_uni(sickDat[j,], CovObj)
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterEvalQ(cl, library(dplyr))
clusterEvalQ(cl, library(numDeriv))
clusterEvalQ(cl, library(matrixcalc))
clusterExport(cl, c("sickDat", "CovObj"), envir = environment())
clusterExport(cl, c("loglik_uni", "loglikgrad_uni", "vector_to_triangle","create_alpha_mat",
"vector_var_matrix_calc_COR", "triangle_to_vector"), envir = .GlobalEnv)
Bmatr <- parSapply(cl = cl, 1:nrow(sickDat), rawFun)
terminateCL()
}
#terminateCL()
Bmatr <- Bmatr %>% (function(list){
L <- length(list)
pelet <- matrix(0, nrow = nrow(list[[1]]), ncol = ncol(list[[1]]))
for(i in 1:L) pelet <- pelet + list[[i]]
pelet
})
return(Bmatr)
}
computeBmatr(cor.matrix_to_norm.matrix(sampleData$sick), Pelet_Cov, ncores = 3)
computeBmatr <- function(sickDat, CovObj, ncores = 1){
if(ncores == 1) {
Bmatr <- lapply(1:nrow(sickDat), function(j) loglikgrad_uni(sickDat[j,], CovObj))
} else {
rawFun <- function(j) loglikgrad_uni(sickDat[j,], CovObj)
cl <<- makeCluster(ncores)
message("Cluster 'cl' opened, saved to global environment.")
clusterEvalQ(cl, library(mvtnorm))
clusterEvalQ(cl, library(dplyr))
clusterEvalQ(cl, library(numDeriv))
clusterEvalQ(cl, library(matrixcalc))
clusterExport(cl, c("sickDat", "CovObj"), envir = environment())
clusterExport(cl, c("loglik_uni", "loglikgrad_uni", "vector_to_triangle","create_alpha_mat",
"vector_var_matrix_calc_COR", "triangle_to_vector"), envir = .GlobalEnv)
Bmatr <- parLapply(cl = cl, 1:nrow(sickDat), rawFun)
terminateCL()
}
Bmatr <- Bmatr %>% (function(list){
L <- length(list)
pelet <- matrix(0, nrow = nrow(list[[1]]), ncol = ncol(list[[1]]))
for(i in 1:L) pelet <- pelet + list[[i]]
pelet
})
return(Bmatr)
}
computeBmatr(cor.matrix_to_norm.matrix(sampleData$sick), Pelet_Cov, ncores = 3)
fisherMatrGrad <- ComputeFisher(Pelet_Cov, sampleData$sick, "Grad")  %>% regularizeMatrix()
fisherMatrGrad <- ComputeFisher(Pelet_Cov, sampleData$sick, "Grad", ncores = 3)  %>% regularizeMatrix()
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/estimationFunctions2.R')
fisherMatrGrad <- ComputeFisher(Pelet_Cov, sampleData$sick, "Grad", ncores = 3)  %>% regularizeMatrix()
tmp <- readline("enter")
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/generalFunctions.R')
ncores <- readline("Please enter number of cores to use or enter 0 to use 'detectCores': ")
ncores
ncores <- numeric(ncores)
ncores
ncores <- readline("Please enter number of cores to use or enter 0 to use 'detectCores': ")
ncores <- as.numeric(ncores)
ncores
det <- detectCores()
det
ncores <- det - 1
ncores
ncores <- readline("Please enter number of cores to use or enter 0 to use 'detectCores': ")
ncores <- as.numeric(ncores)
det <- detectCores()
if(ncores == 0){
ncores <- det - 1
readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm?"))
} else {
}
det <- detectCores()
ncores <- 0
det <- detectCores()
ncores <- 0
while(ncores <= 0 | ncores  >= det){
ncores <- readline(paste0(ncores, " where detected. Please enter number of cores to use: "))
ncores <- as.numeric(ncores)
}
det <- detectCores()
ncores <- 0
while(ncores <= 0 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- as.numeric(ncores)
}
det <- detectCores()
ncores <- 0
while(ncores <= 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
det <- detectCores()
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm? "))
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm? (y)"))
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
message(paste0("R will use ", ncores, "."))
message(paste0("R will use ", ncores, " cores."))
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/generalFunctions.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/generalFunctions.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/generalFunctions.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/bootstraps2.R')
terminateCL()
createSamples
createSamples
create_correlation_matrices
rWishart_ARMA
.GlobalEnv$ncores
promptForCores <- function(){
det <- detectCores()
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans <- 0
while(userans != ncores) userans <- as.numeric(readline("Please re-enter number of cores to use: "))
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
message(paste0("R will use ", ncores, " cores."))
ncores <<- ncores
}
promptForCores <- function(){
det <- detectCores()
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans <- 0
while(userans != ncores) userans <- as.numeric(readline("Please re-enter number of cores to use: "))
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
message(paste0("R will use ", ncores, " cores."))
ncores <<- ncores
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans <- 0
while(userans != ncores) userans <- as.numeric(readline("Please re-enter number of cores to use: "))
userans <- "0"
while(userans != "y") userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores
promptForCores()
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/bootstraps2.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/bootstraps2.R')
terminateCL()
install.packages("optimParallel")
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
Pelet_Cov$returns
Pelet_Cov$convergence
c("Est_DF" = Pelet_Cov$Est_N, "Real_DF" = Tlength)
c("Test" = HypTestResHess$Test, "Sig Level" = HypTestResHess$Significance, "FWER Method" = HypTestResHess$MH_method)
HypTestResHess$Results[order(HypTestResHess$Results$Real),]
HypTestResGrad$Results[order(HypTestResGrad$Results$Real),]
HypTestResComb$Results[order(HypTestResComb$Results$Real),]
wilksTest(Pelet_Cov, sampleData$healthy, sampleData$sick)
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/main_code_noPlots.R')
Pelet_Cov$returns
Pelet_Cov$convergence
c("Est_DF" = Pelet_Cov$Est_N, "Real_DF" = Tlength)
c("Test" = HypTestResHess$Test, "Sig Level" = HypTestResHess$Significance, "FWER Method" = HypTestResHess$MH_method)
HypTestResHess$Results[order(HypTestResHess$Results$Real),]
HypTestResGrad$Results[order(HypTestResGrad$Results$Real),]
HypTestResComb$Results[order(HypTestResComb$Results$Real),]
wilksTest(Pelet_Cov, sampleData$healthy, sampleData$sick)
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans1 <- 0
userans2 <- "0"
while(userans != "y"){
while(userans != ncores){
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans1 <- 0
userans2 <- "0"
while(userans2 != "y"){
while(userans1 != ncores){
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans2 <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans1 <- -1
userans2 <- "0"
while(userans2 != "y"){
while(userans1 != ncores){
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans2 <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans2 <- "0"
while(userans2 != "y"){
while(userans1 != ncores){
userans1 <- -1
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans2 <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans1 <- -1
userans2 <- "0"
while(userans2 != "y"){
while(userans1 != ncores){
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans2 <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores <- function(){
det <- detectCores()
ncores <- 0
userans1 <- -1
userans2 <- "0"
while(userans2 != "y"){
ncores <- 0
userans1 <- -1
userans2 <- "0"
while(userans1 != ncores){
ncores <- 0
while(ncores < 1 | ncores  >= det){
ncores <- readline(paste0(det, " cores where detected. Please enter number of cores to use: "))
ncores <- floor(as.numeric(ncores))
}
userans1 <- as.numeric(readline("Please re-enter number of cores to use: "))
}
userans2 <- readline(paste0(det, " cores detected. ", ncores, " cores will be used. Confirm (y)? "))
}
ncores <<- ncores
message(paste0("R will use ", ncores, " cores. 'ncores' saved to global environemnt."))
}
promptForCores()
promptForCores()
promptForCores()
detectCores()
detectCores(all.tests = TRUE)
detectCores(all.tests = TRUE, logical = FALSE)
detectCores(all.tests = TRUE, logical = TRUE)
detectCores(all.tests = TRUE, logical = FALSE)
detectCores(all.tests = FALSE, logical = FALSE)
source('C:/Users/itama/Google Drive/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Code/bootstraps2.R')
terminateCL()
terminateCL
stopCluster(cl)
SDErrorByFunction
BiasRatio
SDErrorByFunction
source("Main Work/Code/generalFunctions.R")
source("Main Work/code/estimationFunctions2.R")
source("Main Work/code/simulationFunctions.R")
build_parameters(90, 0.4, c(0.4, 0.6))
build_parameters(90, 0.4, c(0.4, 0.6))
tmp <- build_parameters(90, 0.4, c(0.4, 0.6))
tmp$Corr.mat
tmp$Corr.mat
tmp$Corr.mat %>% dim()
tmp$Corr.mat %>% vector_var_matrix_calc_COR() %>% dim()
vector_var_matrix_calc_COR
varmat <- tmp$Corr.mat %>% vector_var_matrix_calc_COR()
tmp <- build_parameters(90, 0.4, c(0.4, 0.6))
tmp$Corr.mat %>% dim()
tt <- Sys.time()
varmat <- tmp$Corr.mat %>% vector_var_matrix_calc_COR()
tt <- Sys.time() - tt
tt
tt2 <- Sys.time()
tmp2 <- eigen(varmat, TRUE)
tt2 <- Sys.time() - tt2
tt2
load("C:/Users/itamarf/Google Drive (itamar.faran@gmail.com)/Documents/Study/05 Year 2018-2019/74445 Masters Thesis/correlation_glm/Main Work/Data/Enviroments/fullRunNoARMA 2018-11-30 21-08-24.RData")
Pelet_Cov$Steps
Pelet_Cov$Log_Optim
Pelet_Cov$Log_Optim[[1]]
Pelet_Cov$Log_Optim[[2]]
Pelet_Cov$Log_Optim[[2]]$counts
Pelet_Cov
Pelet_Cov$returns
Pelet_Cov$Log_Optim[[2:17]]$counts
for(i in 2:17) print(Pelet_Cov$Log_Optim[[i]]$counts)
Pelet_Cov$returns
for(i in 2:17) print(Pelet_Cov$Log_Optim[[i]]$counts)
is.double(varmat)
